1 Introduction
======================================

This document provides a walk-through to create your own Green-Marl program, to compile it and to execute it.  
Before proceed, please read the [Readme documentation](../README.md)  and follow the steps in the document, 
which guides you to build up the compiler and runtime library properly.


2 First program: Hello World
======================================

Now let us write the traditional "Hello World" application with Green-Marl.
Here we will re-use the _makefile_ scripts that are already provided with the sample
application. (This is not mandatory, however; you are free to create your own
makefile scripts, once you get accustomed to Green-Marl environment.)

Also, we recommend the readers to use vim as a text editor, because we provide vim
Syntax-Highlighting support for Green-Marl. See [Readme documentation](../README.md) for details.


2-1 Writing hello_world.gm
--------------------------------------

We will add our new program in $(top)/apps/src
    
    cd $(top)/apps/src
    vi hello_world.gm    %% Start write your code with vi

Now write your first Green-Marl program as follows:

    Procedure hello_world() 
    {
        [ printf("Hello world\n") ];
    }
    
Unfortunately, hello_world program does not exercise much of interesting features of Green-Marl.

**Procedure** is a keyword that indicates a Green-Marl procedure, followed by procedure name and
a (null) argument list (inside the parenthesis) and the procedure body (inside the braces).

There is only one statement in the procedure body. Interestingly the statement is enclosed within a bracket \[ \]. 
This is called _foreign statement_ in Green-Marl, which means that any string inside a bracket
is not Green-Marl statements but the statements of the target language (C++ in our case). The compiler
will simply reproduce this string in the proper place, when generating the target code.


2-2 Compiling hello_world.gm
--------------------------------------

Now we will compile hello_world.gm into target (i.e. C++) code. 
First, let us add hello_world progam to our Makefile script.

    cd $(top)/apps
    vi Programs.mk
    %%%% Programs.mk has the following line:
    %%%%    PROGS=pagerank conduct bc kosaraju 
    %%%% Add hello_world at the end of it:
    %%%%    PROGS=pagerank conduct bc kosaraju hello_world
    
Now we can compile the hello_world program through the following command:

    cd $(top)/apps
    make gen         %% this command generates .cc file out of .gm file
    ls $(top)/apps/output_cpp/generated/hello_world.cc   % check the code has been well created.
 
For your information, the actual shell command invoked by the previous make is as follows:

    cd $(top)/apps/src
    ../../bin/gm_comp -o=../output_cpp/generated -t=cpp_omp hello_world.gm
    
Thus, the above command is invoking gm_comp compiler with 
  -o option (where to put generated code) and
  -t option (what is the target environment -- cpp_omp means C++ with OpenMP)
in addition to the source file, hello_world.gm

Before we move on, let us take a look at what the generated code looks like.

    cd $(top)/apps/output_cpp/generated/
    cat hello_world.cc 
    % The generated code looks like as follows: (may differ slightly depending on compiler version)
    #include "hello_world.h"
    
    void hello_world()
    {
       // Initializations
       gm_rt_initialize();
       
       printf("hello_world\n");
    }
    
Noticeablly, the compiler inserted _runtime_ initialization code at
the function entry.  (If the runtime has been already initialized, the
call to `gm_rt_initialization()` returns immediately.) Other than
that, the compiler simply reproduced the foreign syntax in place, as
expected.


2-3 Creating an executable and Running it
--------------------------------------
Now let us execute the hello_world program on your system.

Notice that your hello_world.cc is a normal c++ file without any
`main()` method in it; it simply contains one function
`hello_world()`, which can be invoked from the `main()` or any other
c++ functions.

Therefore we first create a main file as follows:

    cd $(top)/apps/output_cpp/src
    vi hello_world_main.cc         %% Our makefile script assumes {program}_main.cc 

Write your main function as follows:

    #include "hello_world.h"         // header generated by gm_comp
    
    int main(int argc, char** argv)
    {
        hello_world();               // call to the generated function
    }


Now we can compile the code with the following command:

    cd $(top)/apps/
    make bin
    ls $(top)/apps/output_cpp/bin/hello_world   % check the binary has been created successfully

Before we execute the program, let us review the actual command invoked by the last `make`.
In fact it has invoked g++ compiler nothing but in a quite normal way:
    
    cd $(top)/apps/output_cpp/src
    g++ -O3 -g -I../generated -I../gm_graph/inc -I. -fopenmp   ../generated/hello_world.cc hello_world_main.cc 
        -L../gm_graph/lib -lgmgraph -o ../bin/hello_world

* g++ compiler compiles two source files hello_world.cc and hello_world_main.cc
* -I option specifies include paths. ../gm_graph/inc is where the header files for the gm_graph is located. 
  ../generated/ contains headers generated by gm_comp
* -fopenmp option specifies that our program uses OpenMp. (In this example, OpenMp is used inside the runtime library.)
* The program is linked with the runtime and graph library (gm_graph). 
  -L options specifice where to find the library.

Okay, now we are ready to run your hello_world application.

    cd $(top)/apps/output_cpp/bin/
    ./hello_world     % "hello world" should be printed out. 
    



3 Second program: sum of neighbors in-degree.
======================================

Now we will create another Green-Marl program which performs some basic
graph-analysis.  In this procedure, for each node in the graph, we
will compute the sum of all of its neighbors' in-degree.  This is like, for example,
to sum up the number of followers of all of your followees, in Twitter
network. Once we get this number for every node, we will add up all these
numbers as the final output value. 

For the sake of convenience, we will simply add 
another procedure in hello_world.gm, instead of creating another .gm file.

3-1 Another Green-Marl procedure
--------------------------------------

Edit your $(top)/apps/src/hello_world.gm in following ocde. 
Note that // denotes line-comment just like in C++.

    // your previous procedure
    Procedure hello_word() 
    {      
       [printf("hello world");]
    }
    
    //-----------------------------------------------------
    // Your new procedure. (Proc is a short-hand for Procedure)
    //-----------------------------------------------------
    //   *  G is a directed graph
    //   *  NSum is a node property (i.e. data associated with each node) of G, 
    //      where the type of each data is Int; NSum will be computed by this procedure.
    //   *  This procedure returns an Int value as well (sum of NSum).
    //-----------------------------------------------------
    Proc sum_of_nbr_in_degree(G: Graph, 
                              NSum: Node_Prop<Int>(G)) : Int                           
    {   
        // For each node s in the graph,
        //    assign NSum as the sum of neighbor's in-degree. 
        Foreach (s: G.Nodes) {                
            s.NSum = Sum(t:s.Nbrs) { t.InDegree() }; 
        }        
        
        // return the sum of NSum over all nodes
        Int ret = Sum(s: G.Nodes) {s.NSum};     
        Return ret;
    }

Note that while we included comments to ensure comprehension, in fact,
the code itself is as intuitive as the textual explanation once you
understand the syntax.

We can compile this code with gm_comp just the same as in the previous section.

    cd $(top)/apps
    make gen         %% this command generates .cc file out of .gm file
    
Before we go any further, let us check the generated _header_ file:

    cat $(top)/apps/output_cpp/generated/hello_world.h
    %% It should look like as follows:
    #ifndef GM_GENERATED_CPP_HELLO_WORLD_H
    #define GM_GENERATED_CPP_HELLO_WORLD_H
    
    #include <stdio>                  // include for standard C/C++ libraries
       // .... a few more includes
    #include <omp.h>                  // include for OpenMP
    #include "gm.h"                   // include for Runtime and Graph library            
    
    void hello_world();               // your 1st procedure
    int32_t sum_of_nbrs_in_degree(    // your 2nd procedure
       gm_graph& G, int32_t* G_val);  //   arguments of the procedure
    
    #endif
    

3-2 Another main program
--------------------------------------

Now let us modify main function as well. In this new main function, we will build up a graph 
and make a call to `sum_of_nbr_ini_degree()` function. 

Edit $(top)/apps/output_cpp/src/hello_world_main.cc ss follows:


    int main(int argc, char** argv)
    {
        hello_world();               // call to the generated function
        
        // create an empty graph
        gm_graph G;
        
        // Add 5 nodes in the graph; 
        // Node 0~4 is created.
        for(int i=0;i<5;i++) 
            G.add_node();

        // Add following Edges such that
        //  node 3 has four in-neighbors (node 0,1,2,4) while 4 has one (node 0).
        G.add_edge(0,3); //  0->3
        G.add_edge(1,3); //  1->3
        G.add_edge(2,3); //  2->3
        G.add_edge(4,3); //  4->3
        G.add_edge(0,4); //  0->4


        // Create an array to hold the node property
        int32_t* nsum = new int32_t[G.num_nodes()];
        
        // call to your procedure
        int32_t s = sum_of_nbrs_in_degree(G, nsum);
        
        // print out the results
        printf("[");
        for(int i=0;i<5;i++)
           printf("%d ", nsum[i]);
        printf("]\n");
        printf("total sum = %d\n", s);
    }
    
Now compile and execute the code as previous:    

    cd $(top)/apps/
    make bin
    $(top)/apps/output_cpp/bin/hello_world  


The result should be like as follows:

     [5 4 4 0 4 ]    %% nsum value for each node
     total sum = 17  %% total sum of nsum


3-3 Looking inside the generated code (Optional)
--------------------------------------

In this section, we will investigate the code generated by gm_comp. 
Note that such an investigation is unnecessary in usual cases; it is enough
to make a call to the generated function. 

However, it is always possible to modify the generated code if it is
desired for whatever reason, because the generated code is nothing but
normal c++ code. It is also fairly human-readable.

Now look at the generated code. You will find the code is now more
complicated than before.

    cat $(top)/apps/output_cpp/generated/hello_world.cc

    1:   int32_t sum_of_nbrs_in_degree(gm_graph& G, int32_t* G_NSum)
    2:   {
    3:      //Initializations
    4:      gm_rt_initialize();
    5:      G.freeze();
    6:      G.make_reverse_edges();

The first a few lines are initialization routines. Compared to
`hello_world()` case, you will notice that the compiler has inserted
two more initialization routines: `G.freeze()` and
`G.make_reverse_edges()`. `freeze()` function ensures that the data
representation of the graph is CSR format, which is hard to insert or
delete nodes but fast to iterate over.  `make_reverse_edges()` ensures
the graph has reverse edges; if not, reverse edges are created.  Note
that `make_reverse_edges()` are added only because reverse edge
information will be used later in the procedure.

    7:      int32_t ret;
    8:      int32_t _S2;

The two lines declare variables -- variables whose name start with
underscore(_) are ones that have been inserted by the compiler.

Let us first look at how the neighborhood iteration over all the nodes in the
graph have been generated:

    11:     #pragma omp parallel
    12:     {
                 // ....
    17:        #pragma omp for nowait
    18:        for (node_t s = 0; s < G.num_nodes(); s ++) 
    19:        {
    21:            int32_t _S1;
    22:
    23:            _S1 = 0 ;
    24:            for (edge_t t_idx = G.begin[s];t_idx < G.begin[s+1] ; t_idx ++) 
    25:            {
    26:                node_t t = G.node_idx [t_idx];
    27:                _S1 = _S1 + (G.r_begin[t+1] - G.r_begin[t]) ;
    28:            }
    29:            G_NSum[s] = _S1 ;
    30:            // ...
    31:        }
               // ....       
    40:     }

In the above code, line 11 starts an parallel region; line 17 -- 18 is
 a parallel loop over the nodes in the graph, where each thread will
 execute a subset of the nodes in the graph.  Line 24 -- 28 performs
 neighborhood iteration for the node s, and accumulate in-degree
 (`r_begin[t+1] - r_begin[t]`) into `_S1`. Later, `_S1` becomes the
 `NSum` value for this node.


Now let us consider how the summation of G_NSums is computed.

    10:     _S2 = 0 ;
    11:     #pragma omp parallel
    12:     {
    13:        int32_t _S2_prv;
    14:    
    15:        _S2_prv = 0 ;
    16:    
    17:        #pragma omp for nowait
    18:        for (node_t s = 0; s < G.num_nodes(); s ++) 
    19:        {
                   // ...
    29:            G_NSum[s] = _S1 ;
    30:            _S2_prv = _S2_prv + G_NSum[s] ;
    31:        }
    32:        // reduction
    33:        { 
    34:            int32_t _S2_old, _S2_new;
    35:            do {
    36:                _S2_old = _S2;
    37:                _S2_new = _S2_old + (_S2_prv);
    38:            } while (_gm_atomic_compare_and_swap(&(_S2), _S2_old, _S2_new)==false); 
    39:        }
    40:     }

The sum of NSum is accumulated into the variable (`_S2`). However
inside the parallel region, each thread keeps a private partial sum
(`_S2_prv`), where it accumulates NSum value (line 30). At the end of
the parallel region, each thread updates the global sum (`_S2`) by
doing atomic addition using compare and swap (line 34--38).

Finally, the accumulated value is returned.

    41:     ret = _S2 ;
    42:     return ret; 
    43:  }

Note that although the user suggested two iteration over the nodes in
the graph (one for computing NSum, the other for computing sum of
NSum), the compiler merged those two iteration into one for the sake
of performance improvement.


4 Further information
======================================

Please refer to the following documents for further information

* [Readme.md](../README.md): about set-up and installation
* [Green-Marl language specification](./Green_Marl_language_specification_v_0_3_in_progress.pdf) : about the language (syntax and semantic)
* [gm_comp.md](./gm_comp.md) : about gm_comp compiler
* gm_graph.txt : about c++ runtime and graph library.

